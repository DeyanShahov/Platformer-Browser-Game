<!DOCTYPE html>
<html lang="bg">
<head>
<meta charset="UTF-8" />
<title>Z‑Depth Platformer Collision Test</title>
<style>
  body { margin: 0; background: #111; overflow: hidden; }
  canvas { background: #222; display: block; margin: 0 auto; }
</style>
</head>
<body>
<canvas id="game" width="900" height="500"></canvas>
<script>
//--------------------------------------------------
// BASIC SETUP
//--------------------------------------------------
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

//--------------------------------------------------
// INPUT
//--------------------------------------------------
const keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

//--------------------------------------------------
// ENTITY DEFINITIONS
const Z_MIN = 20;
const Z_MAX = 320;
//--------------------------------------------------
function createEntity(x, y, z, w, h, color) {
  return {
    x, y, z,
    w, h,
    vx: 0,
    vy: 0,
    vz: 0,
    color,
    onGround: false,

    // For attack state
    attacking: false,
    attackTimer: 0,

    // For hit state
    hit: false,
  };
}

const hero = createEntity(100, 400, 0, 50, 50, "#3AA0FF");
const enemy = createEntity(450, 350, 50, 60, 60, "#FF3020"); // Enemy is slightly different Z
const ally = createEntity(420, 340, 80, 50, 50, "#00FF00"); // Ally with different Z

//--------------------------------------------------
// COLLISION LOGIC (ABSTRACT)
//--------------------------------------------------
function checkCollision(ax, ay, az, aw, ah, tx, ty, tz, tw, th, params) {
  const { zTolerance, zThickness } = params;

  const dz = Math.abs(az - tz);
  if (dz > zThickness + zTolerance) return false;

  const ax1 = ax;
  const ay1 = ay;
  const ax2 = ax + aw;
  const ay2 = ay + ah;

  const bx1 = tx;
  const by1 = ty;
  const bx2 = tx + tw;
  const by2 = ty + th;

  const overlap = ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
  return overlap;
}

function checkHitboxCollision(attacker, target, params) {
  return checkCollision(attacker.x, attacker.y, attacker.z, attacker.w, attacker.h,
                        target.x, target.y, target.z, target.w, target.h, params);
}

function canMoveTo(entity, proposedX, proposedY, proposedZ) {
  const others = [enemy, ally].filter(e => e !== entity);
  for (const other of others) {
    if (checkCollision(proposedX, proposedY, proposedZ, entity.w, entity.h,
                      other.x, other.y, other.z, other.w, other.h,
                      { zTolerance: 1, zThickness: 0 })) {
      return false;
    }
  }
  return true;
}

//--------------------------------------------------
// GAME LOOP
//--------------------------------------------------
function update(dt) {
  const speed = 200;
  const zSpeed = speed;     // Пиксели/секунда по Z
  const gravity = 800;

  hero.vx = 0;
  hero.vz = 0; // ВАЖНО – нулираме преди нов вход

  // X движение
  if (keys["ArrowLeft"]) hero.vx = -speed;
  if (keys["ArrowRight"]) hero.vx = speed;

  // Check X movement collision
  const proposedX = hero.x + hero.vx * dt;
  if (!canMoveTo(hero, proposedX, hero.y, hero.z)) {
    hero.vx = 0;
  }

  // Z движение (с граници)
  if (keys["ArrowUp"]) hero.vz = zSpeed;
  if (keys["ArrowDown"]) hero.vz = -zSpeed;

  // Опит за движение по Z
  const proposedZ = hero.z + hero.vz * dt;


  // if (proposedZ >= Z_MIN && proposedZ <= Z_MAX) {
  //   hero.z = proposedZ;
  // } else {
  //   // Ако се удари в граница — clamp
  //   hero.z = Math.min(Math.max(hero.z, Z_MIN), Z_MAX);

  const clampedZ = Math.min(Math.max(proposedZ, Z_MIN), Z_MAX);

  //Check Z movement collision
  if (canMoveTo(hero, hero.x, hero.y, clampedZ)) {
    hero.z = clampedZ;
  }

  // Скок
  if (keys["w"] && hero.onGround) {
    hero.vy = -350;
    hero.onGround = false;
  }

  // Атака
  if (keys["q"] && !hero.attacking) {
    hero.attacking = true;
    hero.attackTimer = 0.2;
  }

  // Реално движение X
  hero.x += hero.vx * dt;

  // Гравитация
  hero.vy += gravity * dt;
  hero.y += hero.vy * dt;

  // Земя
  if (hero.y >= 400) {
    hero.y = 400;
    hero.vy = 0;
    hero.onGround = true;
  }

  // Проверки за атака
  if (hero.attacking) {
    hero.attackTimer -= dt;
    if (hero.attackTimer <= 0) hero.attacking = false;

    if (!enemy.hit) {
      const hit = checkHitboxCollision(hero, enemy, {
        zTolerance: 20,
        zThickness: 40
      });

      if (hit) enemy.hit = true;
    }
  }
}



//--------------------------------------------------
// RENDER
//--------------------------------------------------
function drawEntity(e) {
  const zOffset = e.z * 1.0;
  ctx.fillStyle = e.color;
  ctx.fillRect(e.x, e.y - e.h - zOffset, e.w, e.h);

  if (e.attacking) {
    ctx.strokeStyle = "#FFFF00";
    ctx.strokeRect(e.x - 10, e.y - e.h - zOffset - 10, e.w + 20, e.h + 20);
  }

  if (e.hit) {
    ctx.strokeStyle = "#FFFFFF";
    ctx.beginPath();
    ctx.arc(e.x + e.w/2, e.y - e.h/2 - zOffset, 40, 0, Math.PI*2);
    ctx.stroke();
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // DEBUG Z LINES
  ctx.strokeStyle = "#00FF00";
  ctx.beginPath();
  ctx.moveTo(0, 400 - Z_MIN*1.0);
  ctx.lineTo(canvas.width, 400 - Z_MIN*1.0);
  ctx.stroke();

  ctx.strokeStyle = "#FF00FF";
  ctx.beginPath();
  ctx.moveTo(0, 400 - Z_MAX*1.0);
  ctx.lineTo(canvas.width, 400 - Z_MAX*1.0);
  ctx.stroke();

  // Draw entities in Z order based on bottom position (lower effective Y = background, higher effective Y = foreground)
  const entities = [enemy, hero, ally];
  entities.sort((a, b) => (a.y - a.z) - (b.y - b.z)); // Sort by effective bottom Y ascending
  entities.forEach((entity, index) => {
    drawEntity(entity);
    // Debug text
    ctx.fillStyle = "#FFFFFF";
    ctx.font = "12px Arial";
    const effectiveY = entity.y - entity.z;
    ctx.fillText(`Z:${entity.z.toFixed(1)} EffY:${effectiveY.toFixed(1)} Order:${index+1}`, entity.x, entity.y - entity.h - entity.z - 20);
  });
}

//--------------------------------------------------
// GAME LOOP START
//--------------------------------------------------
let last = 0;
function loop(ts) {
  const dt = (ts - last) / 1000;
  last = ts;

  update(dt);
  render();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
